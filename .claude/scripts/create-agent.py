#!/usr/bin/env python3
"""
Dynamic Agent Creator for Claude Ecosystem
Creates specialized agents on-demand based on requirements
"""

import os
import sys
import json
import argparse
from datetime import datetime
from pathlib import Path

class DynamicAgentCreator:
    def __init__(self):
        self.base_path = Path(__file__).parent.parent
        self.agents_path = self.base_path / "agents"
        self.template_path = self.agents_path / "AGENT_TEMPLATE.md"
        self.colors = ["blue", "green", "red", "purple", "orange", "yellow", "cyan", "magenta"]
        self.used_colors = self._get_used_colors()
        
    def _get_used_colors(self):
        """Get colors already used by existing agents"""
        used = set()
        for agent_file in self.agents_path.glob("*.md"):
            if agent_file.name != "AGENT_TEMPLATE.md":
                with open(agent_file, 'r') as f:
                    content = f.read()
                    if 'color:' in content:
                        for line in content.split('\n'):
                            if line.startswith('color:'):
                                used.add(line.split(':')[1].strip())
        return used
    
    def _select_color(self):
        """Select an unused color for the new agent"""
        available = [c for c in self.colors if c not in self.used_colors]
        if available:
            return available[0]
        return "blue"  # Default if all colors used
    
    def create_agent(self, name, description, capabilities, specialization=None):
        """Create a new specialized agent"""
        
        # Sanitize agent name
        agent_name = name.lower().replace(' ', '-')
        agent_file = self.agents_path / f"{agent_name}.md"
        
        # Check if agent already exists
        if agent_file.exists():
            print(f"‚ö†Ô∏è  Agent '{agent_name}' already exists!")
            response = input("Do you want to update it? (y/n): ")
            if response.lower() != 'y':
                return False
        
        # Generate agent content
        color = self._select_color()
        
        agent_content = f"""---
name: {agent_name}
description: {description}
model: inherit
color: {color}
auto_optimize: true
self_healing: enabled
performance_tracking: active
created_by: Dynamic Agent Creator
created_at: {datetime.now().isoformat()}
version: 1.0.0
---

# {name.upper()} Agent

## Identity & Purpose
**Role**: Specialized agent for {specialization or name} operations
**Created**: Dynamically generated by Supreme Orchestrator
**Status**: Active and self-optimizing

## Core Capabilities
{self._format_capabilities(capabilities)}

## Specialization Areas
{self._generate_specialization(specialization or name)}

## Auto-Optimization Settings
```yaml
optimization:
  self_learning: enabled
  performance_monitoring: active
  auto_correction: enabled
  evolution_mode: continuous
  
  metrics_tracked:
    - response_time
    - success_rate
    - resource_usage
    - user_satisfaction
    
  optimization_triggers:
    - performance_below_threshold
    - repeated_errors
    - new_patterns_detected
    - efficiency_opportunity
```

## Integration Points
```yaml
integrations:
  upstream_agents:
    - master  # Reports to Supreme Orchestrator
    - orchestrator  # Receives coordination commands
    
  peer_agents:
    # Automatically discovered based on workflow
    
  downstream_services:
    # Dynamically configured based on tasks
```

## Self-Diagnostic System
```yaml
health_checks:
  frequency: continuous
  
  monitored_aspects:
    - configuration_validity
    - dependency_availability
    - performance_metrics
    - error_rates
    - resource_consumption
    
  auto_repair_actions:
    - reset_on_freeze
    - clear_error_state
    - restore_from_backup
    - request_orchestrator_help
```

## Knowledge Base
```yaml
knowledge:
  domain_expertise: {specialization or name}
  learning_sources:
    - execution_history
    - peer_agent_patterns
    - user_feedback
    - external_documentation
    
  continuous_learning:
    - pattern_recognition: enabled
    - solution_caching: active
    - technique_absorption: enabled
    - cross_domain_synthesis: active
```

## Execution Patterns
```python
class {name.replace(' ', '')}Agent:
    def __init__(self):
        self.optimization_enabled = True
        self.learning_mode = True
        self.performance_tracking = True
        
    def execute(self, task):
        \"\"\"Execute task with optimization and learning\"\"\"
        # Pre-execution analysis
        self.analyze_task(task)
        
        # Execute with monitoring
        result = self.perform_task(task)
        
        # Learn from execution
        self.learn_from_result(result)
        
        # Optimize for next time
        self.optimize_patterns()
        
        return result
    
    def self_diagnose(self):
        \"\"\"Run self-diagnostic checks\"\"\"
        health_status = {{
            'configuration': self.check_config(),
            'performance': self.check_performance(),
            'errors': self.check_errors(),
            'optimization': self.check_optimization()
        }}
        
        if any(status == 'degraded' for status in health_status.values()):
            self.auto_repair()
        
        return health_status
```

## Performance Benchmarks
```yaml
performance_targets:
  response_time: <1s
  success_rate: >99%
  availability: 99.9%
  resource_efficiency: optimal
  
current_performance:
  # Automatically tracked and updated
  response_time: tracking...
  success_rate: tracking...
  availability: tracking...
  resource_efficiency: tracking...
```

## Evolution History
```yaml
evolution_log:
  - version: 1.0.0
    date: {datetime.now().isoformat()}
    changes: Initial dynamic creation
    created_by: Supreme Orchestrator
```

## Emergency Protocols
```yaml
emergency_handling:
  failure_modes:
    total_failure:
      action: notify_orchestrator
      fallback: manual_intervention
      
    partial_failure:
      action: self_repair
      fallback: request_peer_help
      
    performance_degradation:
      action: auto_optimize
      fallback: scale_resources
```

## Notes
- This agent was dynamically created by the Supreme Orchestrator
- It includes self-optimization and learning capabilities
- Performance is continuously monitored and improved
- The agent will evolve based on usage patterns
"""
        
        # Write agent file
        with open(agent_file, 'w') as f:
            f.write(agent_content)
        
        print(f"‚úÖ Successfully created agent: {agent_name}")
        print(f"üìç Location: {agent_file}")
        print(f"üé® Color: {color}")
        print(f"üöÄ Status: Active and self-optimizing")
        
        # Update registry
        self._update_registry(agent_name, description, capabilities)
        
        return True
    
    def _format_capabilities(self, capabilities):
        """Format capabilities list"""
        if isinstance(capabilities, str):
            capabilities = [cap.strip() for cap in capabilities.split(',')]
        
        formatted = ""
        for cap in capabilities:
            formatted += f"- **{cap}**: Enabled and optimizing\n"
        return formatted
    
    def _generate_specialization(self, domain):
        """Generate specialization details based on domain"""
        specializations = {
            "redis": """
- Cache optimization and management
- Cluster configuration and scaling
- Performance tuning and monitoring
- Data persistence strategies
- Replication and failover handling""",
            
            "postgres": """
- Query optimization and indexing
- Database performance tuning
- Backup and recovery strategies
- Replication and high availability
- Connection pool management""",
            
            "mongodb": """
- Document store optimization
- Sharding and replica sets
- Aggregation pipeline optimization
- Index strategy and management
- Performance monitoring and tuning""",
            
            "nginx": """
- Load balancing configuration
- SSL/TLS optimization
- Caching strategies
- Rate limiting and security
- Performance tuning""",
            
            "elasticsearch": """
- Index optimization and management
- Search query optimization
- Cluster health monitoring
- Shard allocation strategies
- Performance tuning"""
        }
        
        return specializations.get(domain.lower(), f"""
- {domain} configuration management
- Performance optimization
- Security hardening
- Monitoring and alerting
- Troubleshooting and diagnostics""")
    
    def _update_registry(self, agent_name, description, capabilities):
        """Update agent registry"""
        registry_file = self.base_path / "data" / "agent_registry.json"
        
        # Load existing registry or create new
        if registry_file.exists():
            with open(registry_file, 'r') as f:
                registry = json.load(f)
        else:
            registry = {"agents": {}, "created_at": datetime.now().isoformat()}
        
        # Add new agent
        registry["agents"][agent_name] = {
            "description": description,
            "capabilities": capabilities if isinstance(capabilities, list) else [cap.strip() for cap in capabilities.split(',')],
            "created_at": datetime.now().isoformat(),
            "version": "1.0.0",
            "status": "active",
            "performance": {
                "success_rate": 0,
                "total_executions": 0,
                "average_response_time": 0
            }
        }
        
        # Save updated registry
        registry_file.parent.mkdir(exist_ok=True)
        with open(registry_file, 'w') as f:
            json.dump(registry, f, indent=2)
        
        print(f"üìù Updated agent registry")

def main():
    parser = argparse.ArgumentParser(description="Create a new specialized agent dynamically")
    parser.add_argument("name", help="Name of the agent (e.g., 'Redis', 'PostgreSQL')")
    parser.add_argument("-d", "--description", help="Description of the agent's purpose", 
                       default="Specialized agent for optimized operations")
    parser.add_argument("-c", "--capabilities", help="Comma-separated list of capabilities",
                       default="configuration,optimization,monitoring,troubleshooting")
    parser.add_argument("-s", "--specialization", help="Specialization domain", default=None)
    
    args = parser.parse_args()
    
    creator = DynamicAgentCreator()
    success = creator.create_agent(
        args.name,
        args.description,
        args.capabilities,
        args.specialization
    )
    
    if success:
        print("\nüéâ Agent creation successful!")
        print("The agent is now active and will begin self-optimization immediately.")

if __name__ == "__main__":
    main()